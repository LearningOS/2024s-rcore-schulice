# 编程作业

## 1. 更改sys_time和sys_taskinfo

将向用户空间中得到的切片数组的写入封装为函数，接受一个目标类型引用和目的地址指针.
将写入操作更改为使用该函数

## 2.实现sys_mmap和sys_munmap

mmap和munmap都会更改task control block中的memory set，所以需要更改task，添加方法mmap和unmap。
同时，在memory set中也添加方法，下面是memory set中的行为。
map: 查找vec中是否有与将map的范围有重合的area，否则新建area并map，再推入vec中。
unmap：查找与待unmap的区间相等的区间，然后删除映射，再将其从vec中移除。
我假设期望的行为是不能部分unmap已经map的区间，因为这样就足以通过测例。感觉memoryset中的vec更应该使用map，方便按虚拟地址顺序管理区间，也方便零碎的区间进行合并。
在sys_xxx中判断传入的start是否4k对齐，prot是否正确，等等。


# 问答作业

请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？
[63, 54] 保留位
[53, 28]
[27, 19]
[18, 10] 多级PPN
[9, 8] 特权级软件保留
[7, 0] flags
flags作用：判断页面可读可写可执行，记录是否被访问修改，是否全局，是否用户可访问 是否有效。

## 缺页

缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。
请问哪些异常可能是缺页导致的？
1. StoreFault
2. StorePageFault
3. LoadFault
4. LoadPageFault

发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。
    sstatus: 得到触发trap前的进程的特权级状态
    spec：记录异常时应当返回的地址
    sscratch：记录用户栈sp
    scause: 中断触发原因，判断是否是缺页

缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

这样做有哪些好处？
1. 更快的启动程序
2. 节约不必要的内存分配

其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？
估算数量级，则只考虑最外层叶子节点pte，10 * 2^20 kb / 4kb = 10 * 2^18， 10 * 2^18 * 64 / 8 = 10 * 2^21 b = 10 * 2^11 kb = 20 mb

请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

分配带权限的区间MapArea，但是并不map。
只有发生缺页时，查询task cb中存在这样的区间，做些检查，然后map对应的页。

缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

此时页面失效如何表现在页表项(PTE)上？

PTE的valid位会置零

## 双页表与单页表

为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )

在单页表情况下，如何更换页表？
更改对应的memoryset。其中每个memoryset都有一个对应的pagetable在堆区。
单页表下所用的task的pagetable都会有一块一样的内核映射的区间，所以不再需要trampoline段来作为中转。

单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）
设置pte的U位为零

单页表有何优势？（回答合理即可）
进入内核态不需要切换页表，提升中断等行为的响应速度

双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？
在发生中断进入内核态或切换task时，需要更换页表。

# 荣誉准则

## 1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

## 2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

### ch4

- [RISC-V Sv39 虚拟内存总结](https://zhuanlan.zhihu.com/p/626899526)，这里的东西在SV39（上）中都提到了，用这个只是方便找概念。

### Github Copilot Chat usage
- 解释linker脚本，一些riscv汇编指令

## 3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

## 4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
